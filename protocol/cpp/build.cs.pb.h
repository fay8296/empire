// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: build.cs.proto

#ifndef PROTOBUF_build_2ecs_2eproto__INCLUDED
#define PROTOBUF_build_2ecs_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace empire {
namespace msg {
namespace auto {
namespace cs {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_build_2ecs_2eproto();
void protobuf_AssignDesc_build_2ecs_2eproto();
void protobuf_ShutdownFile_build_2ecs_2eproto();

class CSStartBuildMsg;
class CSStartProduceMsg;
class CSStartResearchMsg;
class CSStartUpdateMsg;
class CSQueryResearchInfoMsg;

// ===================================================================

class CSStartBuildMsg : public ::google::protobuf::Message {
 public:
  CSStartBuildMsg();
  virtual ~CSStartBuildMsg();

  CSStartBuildMsg(const CSStartBuildMsg& from);

  inline CSStartBuildMsg& operator=(const CSStartBuildMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSStartBuildMsg& default_instance();

  void Swap(CSStartBuildMsg* other);

  // implements Message ----------------------------------------------

  CSStartBuildMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSStartBuildMsg& from);
  void MergeFrom(const CSStartBuildMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline ::google::protobuf::int32 pos() const;
  inline void set_pos(::google::protobuf::int32 value);

  // optional string tmplId = 2;
  inline bool has_tmplid() const;
  inline void clear_tmplid();
  static const int kTmplIdFieldNumber = 2;
  inline const ::std::string& tmplid() const;
  inline void set_tmplid(const ::std::string& value);
  inline void set_tmplid(const char* value);
  inline void set_tmplid(const char* value, size_t size);
  inline ::std::string* mutable_tmplid();
  inline ::std::string* release_tmplid();
  inline void set_allocated_tmplid(::std::string* tmplid);

  // @@protoc_insertion_point(class_scope:com.empire.msg.auto.cs.CSStartBuildMsg)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_tmplid();
  inline void clear_has_tmplid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* tmplid_;
  ::google::protobuf::int32 pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_build_2ecs_2eproto();
  friend void protobuf_AssignDesc_build_2ecs_2eproto();
  friend void protobuf_ShutdownFile_build_2ecs_2eproto();

  void InitAsDefaultInstance();
  static CSStartBuildMsg* default_instance_;
};
// -------------------------------------------------------------------

class CSStartProduceMsg : public ::google::protobuf::Message {
 public:
  CSStartProduceMsg();
  virtual ~CSStartProduceMsg();

  CSStartProduceMsg(const CSStartProduceMsg& from);

  inline CSStartProduceMsg& operator=(const CSStartProduceMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSStartProduceMsg& default_instance();

  void Swap(CSStartProduceMsg* other);

  // implements Message ----------------------------------------------

  CSStartProduceMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSStartProduceMsg& from);
  void MergeFrom(const CSStartProduceMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string produceTmplId = 2;
  inline bool has_producetmplid() const;
  inline void clear_producetmplid();
  static const int kProduceTmplIdFieldNumber = 2;
  inline const ::std::string& producetmplid() const;
  inline void set_producetmplid(const ::std::string& value);
  inline void set_producetmplid(const char* value);
  inline void set_producetmplid(const char* value, size_t size);
  inline ::std::string* mutable_producetmplid();
  inline ::std::string* release_producetmplid();
  inline void set_allocated_producetmplid(::std::string* producetmplid);

  // optional int32 produceCount = 3;
  inline bool has_producecount() const;
  inline void clear_producecount();
  static const int kProduceCountFieldNumber = 3;
  inline ::google::protobuf::int32 producecount() const;
  inline void set_producecount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.empire.msg.auto.cs.CSStartProduceMsg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_producetmplid();
  inline void clear_has_producetmplid();
  inline void set_has_producecount();
  inline void clear_has_producecount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* producetmplid_;
  ::google::protobuf::int32 producecount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_build_2ecs_2eproto();
  friend void protobuf_AssignDesc_build_2ecs_2eproto();
  friend void protobuf_ShutdownFile_build_2ecs_2eproto();

  void InitAsDefaultInstance();
  static CSStartProduceMsg* default_instance_;
};
// -------------------------------------------------------------------

class CSStartResearchMsg : public ::google::protobuf::Message {
 public:
  CSStartResearchMsg();
  virtual ~CSStartResearchMsg();

  CSStartResearchMsg(const CSStartResearchMsg& from);

  inline CSStartResearchMsg& operator=(const CSStartResearchMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSStartResearchMsg& default_instance();

  void Swap(CSStartResearchMsg* other);

  // implements Message ----------------------------------------------

  CSStartResearchMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSStartResearchMsg& from);
  void MergeFrom(const CSStartResearchMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string researchTmplId = 2;
  inline bool has_researchtmplid() const;
  inline void clear_researchtmplid();
  static const int kResearchTmplIdFieldNumber = 2;
  inline const ::std::string& researchtmplid() const;
  inline void set_researchtmplid(const ::std::string& value);
  inline void set_researchtmplid(const char* value);
  inline void set_researchtmplid(const char* value, size_t size);
  inline ::std::string* mutable_researchtmplid();
  inline ::std::string* release_researchtmplid();
  inline void set_allocated_researchtmplid(::std::string* researchtmplid);

  // @@protoc_insertion_point(class_scope:com.empire.msg.auto.cs.CSStartResearchMsg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_researchtmplid();
  inline void clear_has_researchtmplid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* researchtmplid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_build_2ecs_2eproto();
  friend void protobuf_AssignDesc_build_2ecs_2eproto();
  friend void protobuf_ShutdownFile_build_2ecs_2eproto();

  void InitAsDefaultInstance();
  static CSStartResearchMsg* default_instance_;
};
// -------------------------------------------------------------------

class CSStartUpdateMsg : public ::google::protobuf::Message {
 public:
  CSStartUpdateMsg();
  virtual ~CSStartUpdateMsg();

  CSStartUpdateMsg(const CSStartUpdateMsg& from);

  inline CSStartUpdateMsg& operator=(const CSStartUpdateMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSStartUpdateMsg& default_instance();

  void Swap(CSStartUpdateMsg* other);

  // implements Message ----------------------------------------------

  CSStartUpdateMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSStartUpdateMsg& from);
  void MergeFrom(const CSStartUpdateMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:com.empire.msg.auto.cs.CSStartUpdateMsg)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_build_2ecs_2eproto();
  friend void protobuf_AssignDesc_build_2ecs_2eproto();
  friend void protobuf_ShutdownFile_build_2ecs_2eproto();

  void InitAsDefaultInstance();
  static CSStartUpdateMsg* default_instance_;
};
// -------------------------------------------------------------------

class CSQueryResearchInfoMsg : public ::google::protobuf::Message {
 public:
  CSQueryResearchInfoMsg();
  virtual ~CSQueryResearchInfoMsg();

  CSQueryResearchInfoMsg(const CSQueryResearchInfoMsg& from);

  inline CSQueryResearchInfoMsg& operator=(const CSQueryResearchInfoMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSQueryResearchInfoMsg& default_instance();

  void Swap(CSQueryResearchInfoMsg* other);

  // implements Message ----------------------------------------------

  CSQueryResearchInfoMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSQueryResearchInfoMsg& from);
  void MergeFrom(const CSQueryResearchInfoMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:com.empire.msg.auto.cs.CSQueryResearchInfoMsg)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_build_2ecs_2eproto();
  friend void protobuf_AssignDesc_build_2ecs_2eproto();
  friend void protobuf_ShutdownFile_build_2ecs_2eproto();

  void InitAsDefaultInstance();
  static CSQueryResearchInfoMsg* default_instance_;
};
// ===================================================================


// ===================================================================

// CSStartBuildMsg

// optional int32 pos = 1;
inline bool CSStartBuildMsg::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSStartBuildMsg::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSStartBuildMsg::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSStartBuildMsg::clear_pos() {
  pos_ = 0;
  clear_has_pos();
}
inline ::google::protobuf::int32 CSStartBuildMsg::pos() const {
  return pos_;
}
inline void CSStartBuildMsg::set_pos(::google::protobuf::int32 value) {
  set_has_pos();
  pos_ = value;
}

// optional string tmplId = 2;
inline bool CSStartBuildMsg::has_tmplid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSStartBuildMsg::set_has_tmplid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSStartBuildMsg::clear_has_tmplid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSStartBuildMsg::clear_tmplid() {
  if (tmplid_ != &::google::protobuf::internal::kEmptyString) {
    tmplid_->clear();
  }
  clear_has_tmplid();
}
inline const ::std::string& CSStartBuildMsg::tmplid() const {
  return *tmplid_;
}
inline void CSStartBuildMsg::set_tmplid(const ::std::string& value) {
  set_has_tmplid();
  if (tmplid_ == &::google::protobuf::internal::kEmptyString) {
    tmplid_ = new ::std::string;
  }
  tmplid_->assign(value);
}
inline void CSStartBuildMsg::set_tmplid(const char* value) {
  set_has_tmplid();
  if (tmplid_ == &::google::protobuf::internal::kEmptyString) {
    tmplid_ = new ::std::string;
  }
  tmplid_->assign(value);
}
inline void CSStartBuildMsg::set_tmplid(const char* value, size_t size) {
  set_has_tmplid();
  if (tmplid_ == &::google::protobuf::internal::kEmptyString) {
    tmplid_ = new ::std::string;
  }
  tmplid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSStartBuildMsg::mutable_tmplid() {
  set_has_tmplid();
  if (tmplid_ == &::google::protobuf::internal::kEmptyString) {
    tmplid_ = new ::std::string;
  }
  return tmplid_;
}
inline ::std::string* CSStartBuildMsg::release_tmplid() {
  clear_has_tmplid();
  if (tmplid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tmplid_;
    tmplid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSStartBuildMsg::set_allocated_tmplid(::std::string* tmplid) {
  if (tmplid_ != &::google::protobuf::internal::kEmptyString) {
    delete tmplid_;
  }
  if (tmplid) {
    set_has_tmplid();
    tmplid_ = tmplid;
  } else {
    clear_has_tmplid();
    tmplid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSStartProduceMsg

// optional string id = 1;
inline bool CSStartProduceMsg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSStartProduceMsg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSStartProduceMsg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSStartProduceMsg::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& CSStartProduceMsg::id() const {
  return *id_;
}
inline void CSStartProduceMsg::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CSStartProduceMsg::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CSStartProduceMsg::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSStartProduceMsg::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* CSStartProduceMsg::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSStartProduceMsg::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string produceTmplId = 2;
inline bool CSStartProduceMsg::has_producetmplid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSStartProduceMsg::set_has_producetmplid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSStartProduceMsg::clear_has_producetmplid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSStartProduceMsg::clear_producetmplid() {
  if (producetmplid_ != &::google::protobuf::internal::kEmptyString) {
    producetmplid_->clear();
  }
  clear_has_producetmplid();
}
inline const ::std::string& CSStartProduceMsg::producetmplid() const {
  return *producetmplid_;
}
inline void CSStartProduceMsg::set_producetmplid(const ::std::string& value) {
  set_has_producetmplid();
  if (producetmplid_ == &::google::protobuf::internal::kEmptyString) {
    producetmplid_ = new ::std::string;
  }
  producetmplid_->assign(value);
}
inline void CSStartProduceMsg::set_producetmplid(const char* value) {
  set_has_producetmplid();
  if (producetmplid_ == &::google::protobuf::internal::kEmptyString) {
    producetmplid_ = new ::std::string;
  }
  producetmplid_->assign(value);
}
inline void CSStartProduceMsg::set_producetmplid(const char* value, size_t size) {
  set_has_producetmplid();
  if (producetmplid_ == &::google::protobuf::internal::kEmptyString) {
    producetmplid_ = new ::std::string;
  }
  producetmplid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSStartProduceMsg::mutable_producetmplid() {
  set_has_producetmplid();
  if (producetmplid_ == &::google::protobuf::internal::kEmptyString) {
    producetmplid_ = new ::std::string;
  }
  return producetmplid_;
}
inline ::std::string* CSStartProduceMsg::release_producetmplid() {
  clear_has_producetmplid();
  if (producetmplid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = producetmplid_;
    producetmplid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSStartProduceMsg::set_allocated_producetmplid(::std::string* producetmplid) {
  if (producetmplid_ != &::google::protobuf::internal::kEmptyString) {
    delete producetmplid_;
  }
  if (producetmplid) {
    set_has_producetmplid();
    producetmplid_ = producetmplid;
  } else {
    clear_has_producetmplid();
    producetmplid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 produceCount = 3;
inline bool CSStartProduceMsg::has_producecount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSStartProduceMsg::set_has_producecount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSStartProduceMsg::clear_has_producecount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSStartProduceMsg::clear_producecount() {
  producecount_ = 0;
  clear_has_producecount();
}
inline ::google::protobuf::int32 CSStartProduceMsg::producecount() const {
  return producecount_;
}
inline void CSStartProduceMsg::set_producecount(::google::protobuf::int32 value) {
  set_has_producecount();
  producecount_ = value;
}

// -------------------------------------------------------------------

// CSStartResearchMsg

// optional string id = 1;
inline bool CSStartResearchMsg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSStartResearchMsg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSStartResearchMsg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSStartResearchMsg::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& CSStartResearchMsg::id() const {
  return *id_;
}
inline void CSStartResearchMsg::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CSStartResearchMsg::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CSStartResearchMsg::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSStartResearchMsg::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* CSStartResearchMsg::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSStartResearchMsg::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string researchTmplId = 2;
inline bool CSStartResearchMsg::has_researchtmplid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSStartResearchMsg::set_has_researchtmplid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSStartResearchMsg::clear_has_researchtmplid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSStartResearchMsg::clear_researchtmplid() {
  if (researchtmplid_ != &::google::protobuf::internal::kEmptyString) {
    researchtmplid_->clear();
  }
  clear_has_researchtmplid();
}
inline const ::std::string& CSStartResearchMsg::researchtmplid() const {
  return *researchtmplid_;
}
inline void CSStartResearchMsg::set_researchtmplid(const ::std::string& value) {
  set_has_researchtmplid();
  if (researchtmplid_ == &::google::protobuf::internal::kEmptyString) {
    researchtmplid_ = new ::std::string;
  }
  researchtmplid_->assign(value);
}
inline void CSStartResearchMsg::set_researchtmplid(const char* value) {
  set_has_researchtmplid();
  if (researchtmplid_ == &::google::protobuf::internal::kEmptyString) {
    researchtmplid_ = new ::std::string;
  }
  researchtmplid_->assign(value);
}
inline void CSStartResearchMsg::set_researchtmplid(const char* value, size_t size) {
  set_has_researchtmplid();
  if (researchtmplid_ == &::google::protobuf::internal::kEmptyString) {
    researchtmplid_ = new ::std::string;
  }
  researchtmplid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSStartResearchMsg::mutable_researchtmplid() {
  set_has_researchtmplid();
  if (researchtmplid_ == &::google::protobuf::internal::kEmptyString) {
    researchtmplid_ = new ::std::string;
  }
  return researchtmplid_;
}
inline ::std::string* CSStartResearchMsg::release_researchtmplid() {
  clear_has_researchtmplid();
  if (researchtmplid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = researchtmplid_;
    researchtmplid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSStartResearchMsg::set_allocated_researchtmplid(::std::string* researchtmplid) {
  if (researchtmplid_ != &::google::protobuf::internal::kEmptyString) {
    delete researchtmplid_;
  }
  if (researchtmplid) {
    set_has_researchtmplid();
    researchtmplid_ = researchtmplid;
  } else {
    clear_has_researchtmplid();
    researchtmplid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSStartUpdateMsg

// optional string id = 1;
inline bool CSStartUpdateMsg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSStartUpdateMsg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSStartUpdateMsg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSStartUpdateMsg::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& CSStartUpdateMsg::id() const {
  return *id_;
}
inline void CSStartUpdateMsg::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CSStartUpdateMsg::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CSStartUpdateMsg::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSStartUpdateMsg::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* CSStartUpdateMsg::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSStartUpdateMsg::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSQueryResearchInfoMsg


// @@protoc_insertion_point(namespace_scope)

}  // namespace cs
}  // namespace auto
}  // namespace msg
}  // namespace empire
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_build_2ecs_2eproto__INCLUDED
