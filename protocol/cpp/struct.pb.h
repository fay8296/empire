// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: struct.proto

#ifndef PROTOBUF_struct_2eproto__INCLUDED
#define PROTOBUF_struct_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace empire {
namespace msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_struct_2eproto();
void protobuf_AssignDesc_struct_2eproto();
void protobuf_ShutdownFile_struct_2eproto();

class ServerInfo;
class BuildInfo;
class BoatInfo;

enum MallItemState {
  SELL = 0,
  UNSELL = 1
};
bool MallItemState_IsValid(int value);
const MallItemState MallItemState_MIN = SELL;
const MallItemState MallItemState_MAX = UNSELL;
const int MallItemState_ARRAYSIZE = MallItemState_MAX + 1;

const ::google::protobuf::EnumDescriptor* MallItemState_descriptor();
inline const ::std::string& MallItemState_Name(MallItemState value) {
  return ::google::protobuf::internal::NameOfEnum(
    MallItemState_descriptor(), value);
}
inline bool MallItemState_Parse(
    const ::std::string& name, MallItemState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MallItemState>(
    MallItemState_descriptor(), name, value);
}
enum BuildState {
  BUILDING = 0,
  PRODUCING = 1,
  UPDATING = 2,
  RESEARCHING = 3
};
bool BuildState_IsValid(int value);
const BuildState BuildState_MIN = BUILDING;
const BuildState BuildState_MAX = RESEARCHING;
const int BuildState_ARRAYSIZE = BuildState_MAX + 1;

const ::google::protobuf::EnumDescriptor* BuildState_descriptor();
inline const ::std::string& BuildState_Name(BuildState value) {
  return ::google::protobuf::internal::NameOfEnum(
    BuildState_descriptor(), value);
}
inline bool BuildState_Parse(
    const ::std::string& name, BuildState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BuildState>(
    BuildState_descriptor(), name, value);
}
enum MessageType {
  CS_USER_PASSWD = 1
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = CS_USER_PASSWD;
const MessageType MessageType_MAX = CS_USER_PASSWD;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageType_descriptor(), value);
}
inline bool MessageType_Parse(
    const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
enum ErrorType {
  NET_DISCONN = 1
};
bool ErrorType_IsValid(int value);
const ErrorType ErrorType_MIN = NET_DISCONN;
const ErrorType ErrorType_MAX = NET_DISCONN;
const int ErrorType_ARRAYSIZE = ErrorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ErrorType_descriptor();
inline const ::std::string& ErrorType_Name(ErrorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ErrorType_descriptor(), value);
}
inline bool ErrorType_Parse(
    const ::std::string& name, ErrorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrorType>(
    ErrorType_descriptor(), name, value);
}
enum BattlePropertyType {
  TEST = 1
};
bool BattlePropertyType_IsValid(int value);
const BattlePropertyType BattlePropertyType_MIN = TEST;
const BattlePropertyType BattlePropertyType_MAX = TEST;
const int BattlePropertyType_ARRAYSIZE = BattlePropertyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* BattlePropertyType_descriptor();
inline const ::std::string& BattlePropertyType_Name(BattlePropertyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    BattlePropertyType_descriptor(), value);
}
inline bool BattlePropertyType_Parse(
    const ::std::string& name, BattlePropertyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BattlePropertyType>(
    BattlePropertyType_descriptor(), name, value);
}
// ===================================================================

class ServerInfo : public ::google::protobuf::Message {
 public:
  ServerInfo();
  virtual ~ServerInfo();

  ServerInfo(const ServerInfo& from);

  inline ServerInfo& operator=(const ServerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerInfo& default_instance();

  void Swap(ServerInfo* other);

  // implements Message ----------------------------------------------

  ServerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerInfo& from);
  void MergeFrom(const ServerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional string ports = 2;
  inline bool has_ports() const;
  inline void clear_ports();
  static const int kPortsFieldNumber = 2;
  inline const ::std::string& ports() const;
  inline void set_ports(const ::std::string& value);
  inline void set_ports(const char* value);
  inline void set_ports(const char* value, size_t size);
  inline ::std::string* mutable_ports();
  inline ::std::string* release_ports();
  inline void set_allocated_ports(::std::string* ports);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:com.empire.msg.ServerInfo)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_ports();
  inline void clear_has_ports();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ip_;
  ::std::string* ports_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_struct_2eproto();
  friend void protobuf_AssignDesc_struct_2eproto();
  friend void protobuf_ShutdownFile_struct_2eproto();

  void InitAsDefaultInstance();
  static ServerInfo* default_instance_;
};
// -------------------------------------------------------------------

class BuildInfo : public ::google::protobuf::Message {
 public:
  BuildInfo();
  virtual ~BuildInfo();

  BuildInfo(const BuildInfo& from);

  inline BuildInfo& operator=(const BuildInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuildInfo& default_instance();

  void Swap(BuildInfo* other);

  // implements Message ----------------------------------------------

  BuildInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuildInfo& from);
  void MergeFrom(const BuildInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string tmplId = 2;
  inline bool has_tmplid() const;
  inline void clear_tmplid();
  static const int kTmplIdFieldNumber = 2;
  inline const ::std::string& tmplid() const;
  inline void set_tmplid(const ::std::string& value);
  inline void set_tmplid(const char* value);
  inline void set_tmplid(const char* value, size_t size);
  inline ::std::string* mutable_tmplid();
  inline ::std::string* release_tmplid();
  inline void set_allocated_tmplid(::std::string* tmplid);

  // optional int32 lvl = 3;
  inline bool has_lvl() const;
  inline void clear_lvl();
  static const int kLvlFieldNumber = 3;
  inline ::google::protobuf::int32 lvl() const;
  inline void set_lvl(::google::protobuf::int32 value);

  // optional int32 pos = 4;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 4;
  inline ::google::protobuf::int32 pos() const;
  inline void set_pos(::google::protobuf::int32 value);

  // optional .com.empire.msg.BuildState state = 5;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 5;
  inline ::com::empire::msg::BuildState state() const;
  inline void set_state(::com::empire::msg::BuildState value);

  // optional int32 leftTime = 6;
  inline bool has_lefttime() const;
  inline void clear_lefttime();
  static const int kLeftTimeFieldNumber = 6;
  inline ::google::protobuf::int32 lefttime() const;
  inline void set_lefttime(::google::protobuf::int32 value);

  // optional string produceId = 7;
  inline bool has_produceid() const;
  inline void clear_produceid();
  static const int kProduceIdFieldNumber = 7;
  inline const ::std::string& produceid() const;
  inline void set_produceid(const ::std::string& value);
  inline void set_produceid(const char* value);
  inline void set_produceid(const char* value, size_t size);
  inline ::std::string* mutable_produceid();
  inline ::std::string* release_produceid();
  inline void set_allocated_produceid(::std::string* produceid);

  // @@protoc_insertion_point(class_scope:com.empire.msg.BuildInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_tmplid();
  inline void clear_has_tmplid();
  inline void set_has_lvl();
  inline void clear_has_lvl();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_lefttime();
  inline void clear_has_lefttime();
  inline void set_has_produceid();
  inline void clear_has_produceid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* tmplid_;
  ::google::protobuf::int32 lvl_;
  ::google::protobuf::int32 pos_;
  int state_;
  ::google::protobuf::int32 lefttime_;
  ::std::string* produceid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_struct_2eproto();
  friend void protobuf_AssignDesc_struct_2eproto();
  friend void protobuf_ShutdownFile_struct_2eproto();

  void InitAsDefaultInstance();
  static BuildInfo* default_instance_;
};
// -------------------------------------------------------------------

class BoatInfo : public ::google::protobuf::Message {
 public:
  BoatInfo();
  virtual ~BoatInfo();

  BoatInfo(const BoatInfo& from);

  inline BoatInfo& operator=(const BoatInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BoatInfo& default_instance();

  void Swap(BoatInfo* other);

  // implements Message ----------------------------------------------

  BoatInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BoatInfo& from);
  void MergeFrom(const BoatInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string tmplId = 2;
  inline bool has_tmplid() const;
  inline void clear_tmplid();
  static const int kTmplIdFieldNumber = 2;
  inline const ::std::string& tmplid() const;
  inline void set_tmplid(const ::std::string& value);
  inline void set_tmplid(const char* value);
  inline void set_tmplid(const char* value, size_t size);
  inline ::std::string* mutable_tmplid();
  inline ::std::string* release_tmplid();
  inline void set_allocated_tmplid(::std::string* tmplid);

  // optional int32 pos = 3;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 3;
  inline ::google::protobuf::int32 pos() const;
  inline void set_pos(::google::protobuf::int32 value);

  // optional int32 count = 4;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 4;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.empire.msg.BoatInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_tmplid();
  inline void clear_has_tmplid();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* tmplid_;
  ::google::protobuf::int32 pos_;
  ::google::protobuf::int32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_struct_2eproto();
  friend void protobuf_AssignDesc_struct_2eproto();
  friend void protobuf_ShutdownFile_struct_2eproto();

  void InitAsDefaultInstance();
  static BoatInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// ServerInfo

// optional string ip = 1;
inline bool ServerInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerInfo::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& ServerInfo::ip() const {
  return *ip_;
}
inline void ServerInfo::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void ServerInfo::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void ServerInfo::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfo::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* ServerInfo::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfo::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ports = 2;
inline bool ServerInfo::has_ports() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerInfo::set_has_ports() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerInfo::clear_has_ports() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerInfo::clear_ports() {
  if (ports_ != &::google::protobuf::internal::kEmptyString) {
    ports_->clear();
  }
  clear_has_ports();
}
inline const ::std::string& ServerInfo::ports() const {
  return *ports_;
}
inline void ServerInfo::set_ports(const ::std::string& value) {
  set_has_ports();
  if (ports_ == &::google::protobuf::internal::kEmptyString) {
    ports_ = new ::std::string;
  }
  ports_->assign(value);
}
inline void ServerInfo::set_ports(const char* value) {
  set_has_ports();
  if (ports_ == &::google::protobuf::internal::kEmptyString) {
    ports_ = new ::std::string;
  }
  ports_->assign(value);
}
inline void ServerInfo::set_ports(const char* value, size_t size) {
  set_has_ports();
  if (ports_ == &::google::protobuf::internal::kEmptyString) {
    ports_ = new ::std::string;
  }
  ports_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfo::mutable_ports() {
  set_has_ports();
  if (ports_ == &::google::protobuf::internal::kEmptyString) {
    ports_ = new ::std::string;
  }
  return ports_;
}
inline ::std::string* ServerInfo::release_ports() {
  clear_has_ports();
  if (ports_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ports_;
    ports_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfo::set_allocated_ports(::std::string* ports) {
  if (ports_ != &::google::protobuf::internal::kEmptyString) {
    delete ports_;
  }
  if (ports) {
    set_has_ports();
    ports_ = ports;
  } else {
    clear_has_ports();
    ports_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 3;
inline bool ServerInfo::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerInfo::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ServerInfo::name() const {
  return *name_;
}
inline void ServerInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ServerInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ServerInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ServerInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BuildInfo

// optional string id = 1;
inline bool BuildInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuildInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuildInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuildInfo::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& BuildInfo::id() const {
  return *id_;
}
inline void BuildInfo::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void BuildInfo::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void BuildInfo::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuildInfo::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* BuildInfo::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BuildInfo::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string tmplId = 2;
inline bool BuildInfo::has_tmplid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuildInfo::set_has_tmplid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuildInfo::clear_has_tmplid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuildInfo::clear_tmplid() {
  if (tmplid_ != &::google::protobuf::internal::kEmptyString) {
    tmplid_->clear();
  }
  clear_has_tmplid();
}
inline const ::std::string& BuildInfo::tmplid() const {
  return *tmplid_;
}
inline void BuildInfo::set_tmplid(const ::std::string& value) {
  set_has_tmplid();
  if (tmplid_ == &::google::protobuf::internal::kEmptyString) {
    tmplid_ = new ::std::string;
  }
  tmplid_->assign(value);
}
inline void BuildInfo::set_tmplid(const char* value) {
  set_has_tmplid();
  if (tmplid_ == &::google::protobuf::internal::kEmptyString) {
    tmplid_ = new ::std::string;
  }
  tmplid_->assign(value);
}
inline void BuildInfo::set_tmplid(const char* value, size_t size) {
  set_has_tmplid();
  if (tmplid_ == &::google::protobuf::internal::kEmptyString) {
    tmplid_ = new ::std::string;
  }
  tmplid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuildInfo::mutable_tmplid() {
  set_has_tmplid();
  if (tmplid_ == &::google::protobuf::internal::kEmptyString) {
    tmplid_ = new ::std::string;
  }
  return tmplid_;
}
inline ::std::string* BuildInfo::release_tmplid() {
  clear_has_tmplid();
  if (tmplid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tmplid_;
    tmplid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BuildInfo::set_allocated_tmplid(::std::string* tmplid) {
  if (tmplid_ != &::google::protobuf::internal::kEmptyString) {
    delete tmplid_;
  }
  if (tmplid) {
    set_has_tmplid();
    tmplid_ = tmplid;
  } else {
    clear_has_tmplid();
    tmplid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 lvl = 3;
inline bool BuildInfo::has_lvl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuildInfo::set_has_lvl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuildInfo::clear_has_lvl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuildInfo::clear_lvl() {
  lvl_ = 0;
  clear_has_lvl();
}
inline ::google::protobuf::int32 BuildInfo::lvl() const {
  return lvl_;
}
inline void BuildInfo::set_lvl(::google::protobuf::int32 value) {
  set_has_lvl();
  lvl_ = value;
}

// optional int32 pos = 4;
inline bool BuildInfo::has_pos() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BuildInfo::set_has_pos() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BuildInfo::clear_has_pos() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BuildInfo::clear_pos() {
  pos_ = 0;
  clear_has_pos();
}
inline ::google::protobuf::int32 BuildInfo::pos() const {
  return pos_;
}
inline void BuildInfo::set_pos(::google::protobuf::int32 value) {
  set_has_pos();
  pos_ = value;
}

// optional .com.empire.msg.BuildState state = 5;
inline bool BuildInfo::has_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BuildInfo::set_has_state() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BuildInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BuildInfo::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::com::empire::msg::BuildState BuildInfo::state() const {
  return static_cast< ::com::empire::msg::BuildState >(state_);
}
inline void BuildInfo::set_state(::com::empire::msg::BuildState value) {
  assert(::com::empire::msg::BuildState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional int32 leftTime = 6;
inline bool BuildInfo::has_lefttime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BuildInfo::set_has_lefttime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BuildInfo::clear_has_lefttime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BuildInfo::clear_lefttime() {
  lefttime_ = 0;
  clear_has_lefttime();
}
inline ::google::protobuf::int32 BuildInfo::lefttime() const {
  return lefttime_;
}
inline void BuildInfo::set_lefttime(::google::protobuf::int32 value) {
  set_has_lefttime();
  lefttime_ = value;
}

// optional string produceId = 7;
inline bool BuildInfo::has_produceid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BuildInfo::set_has_produceid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BuildInfo::clear_has_produceid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BuildInfo::clear_produceid() {
  if (produceid_ != &::google::protobuf::internal::kEmptyString) {
    produceid_->clear();
  }
  clear_has_produceid();
}
inline const ::std::string& BuildInfo::produceid() const {
  return *produceid_;
}
inline void BuildInfo::set_produceid(const ::std::string& value) {
  set_has_produceid();
  if (produceid_ == &::google::protobuf::internal::kEmptyString) {
    produceid_ = new ::std::string;
  }
  produceid_->assign(value);
}
inline void BuildInfo::set_produceid(const char* value) {
  set_has_produceid();
  if (produceid_ == &::google::protobuf::internal::kEmptyString) {
    produceid_ = new ::std::string;
  }
  produceid_->assign(value);
}
inline void BuildInfo::set_produceid(const char* value, size_t size) {
  set_has_produceid();
  if (produceid_ == &::google::protobuf::internal::kEmptyString) {
    produceid_ = new ::std::string;
  }
  produceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BuildInfo::mutable_produceid() {
  set_has_produceid();
  if (produceid_ == &::google::protobuf::internal::kEmptyString) {
    produceid_ = new ::std::string;
  }
  return produceid_;
}
inline ::std::string* BuildInfo::release_produceid() {
  clear_has_produceid();
  if (produceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = produceid_;
    produceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BuildInfo::set_allocated_produceid(::std::string* produceid) {
  if (produceid_ != &::google::protobuf::internal::kEmptyString) {
    delete produceid_;
  }
  if (produceid) {
    set_has_produceid();
    produceid_ = produceid;
  } else {
    clear_has_produceid();
    produceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BoatInfo

// optional string id = 1;
inline bool BoatInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BoatInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BoatInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BoatInfo::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& BoatInfo::id() const {
  return *id_;
}
inline void BoatInfo::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void BoatInfo::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void BoatInfo::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BoatInfo::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* BoatInfo::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BoatInfo::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string tmplId = 2;
inline bool BoatInfo::has_tmplid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BoatInfo::set_has_tmplid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BoatInfo::clear_has_tmplid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BoatInfo::clear_tmplid() {
  if (tmplid_ != &::google::protobuf::internal::kEmptyString) {
    tmplid_->clear();
  }
  clear_has_tmplid();
}
inline const ::std::string& BoatInfo::tmplid() const {
  return *tmplid_;
}
inline void BoatInfo::set_tmplid(const ::std::string& value) {
  set_has_tmplid();
  if (tmplid_ == &::google::protobuf::internal::kEmptyString) {
    tmplid_ = new ::std::string;
  }
  tmplid_->assign(value);
}
inline void BoatInfo::set_tmplid(const char* value) {
  set_has_tmplid();
  if (tmplid_ == &::google::protobuf::internal::kEmptyString) {
    tmplid_ = new ::std::string;
  }
  tmplid_->assign(value);
}
inline void BoatInfo::set_tmplid(const char* value, size_t size) {
  set_has_tmplid();
  if (tmplid_ == &::google::protobuf::internal::kEmptyString) {
    tmplid_ = new ::std::string;
  }
  tmplid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BoatInfo::mutable_tmplid() {
  set_has_tmplid();
  if (tmplid_ == &::google::protobuf::internal::kEmptyString) {
    tmplid_ = new ::std::string;
  }
  return tmplid_;
}
inline ::std::string* BoatInfo::release_tmplid() {
  clear_has_tmplid();
  if (tmplid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tmplid_;
    tmplid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BoatInfo::set_allocated_tmplid(::std::string* tmplid) {
  if (tmplid_ != &::google::protobuf::internal::kEmptyString) {
    delete tmplid_;
  }
  if (tmplid) {
    set_has_tmplid();
    tmplid_ = tmplid;
  } else {
    clear_has_tmplid();
    tmplid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 pos = 3;
inline bool BoatInfo::has_pos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BoatInfo::set_has_pos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BoatInfo::clear_has_pos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BoatInfo::clear_pos() {
  pos_ = 0;
  clear_has_pos();
}
inline ::google::protobuf::int32 BoatInfo::pos() const {
  return pos_;
}
inline void BoatInfo::set_pos(::google::protobuf::int32 value) {
  set_has_pos();
  pos_ = value;
}

// optional int32 count = 4;
inline bool BoatInfo::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BoatInfo::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BoatInfo::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BoatInfo::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 BoatInfo::count() const {
  return count_;
}
inline void BoatInfo::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace msg
}  // namespace empire
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::empire::msg::MallItemState>() {
  return ::com::empire::msg::MallItemState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::empire::msg::BuildState>() {
  return ::com::empire::msg::BuildState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::empire::msg::MessageType>() {
  return ::com::empire::msg::MessageType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::empire::msg::ErrorType>() {
  return ::com::empire::msg::ErrorType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::empire::msg::BattlePropertyType>() {
  return ::com::empire::msg::BattlePropertyType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_struct_2eproto__INCLUDED
